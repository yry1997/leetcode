## 题目
[LeetCode题目链接：1695. 删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/?envType=daily-question&envId=2025-07-22)

难度：中等

给你一个正整数数组`nums`，请你从中删除一个含有**若干不同元素**的子数组。删除子数组的**得分**就是子数组各元素之**和**。

返回**只删除一个**子数组可获得的 **最大得分** 。

如果数组 `b` 是数组 `a` 的一个连续子序列，即如果它等于 `a[l],a[l+1],...,a[r]` ，那么它就是 `a` 的一个子数组。

## 题解

**思路**：使用双指针记录子数组的左右端点，右端点从左到右遍历，当遇到重复元素时（借助哈希表），则左端点右移至无重复。

### python代码

```python
class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        '''
        dic1 = defaultdict(int)
        dic2 = defaultdict(int)
        
        def push_dic(x: int) -> None:
            if dic2.get(x) is None:
                if dic1.get(x) is None:
                    dic1[x] = 1
                else:
                    dic2[x] = 2
                    del dic1[x]
            else:
                dic2[x] += 1
        
        def pop_dic(x: int) -> None:
            if dic2.get(x) is not None:
                dic2[x] -= 1
                if dic2[x] == 1:
                    del dic2[x]
                    dic1[x] = 1
            else:
                del dic1[x]
            
        l, r, tmp, res = 0, 0, 0, 0
        n = len(nums)
        while r<n:
            push_dic(nums[r])
            tmp += nums[r]
            r += 1
            while l<r and len(dic2)>0:
                pop_dic(nums[l])
                tmp -= nums[l]
                l += 1
            while r<n and (nums[r] not in dic1):
                push_dic(nums[r])
                tmp += nums[r]
                r += 1
            res = max(res,tmp)
        return res
        '''
        dic = defaultdict(int)
        l, tmp, res = 0, 0, 0
        for i in range(len(nums)):
            if dic.get(nums[i]):
                res = max(res,tmp)
                while l<i and dic.get(nums[i]):
                    tmp -= nums[l]
                    del dic[nums[l]]
                    l += 1
            dic[nums[i]] = 1
            tmp += nums[i]
        if dic.get(nums[-1]):
            res = max(res,tmp)
        return res
```
