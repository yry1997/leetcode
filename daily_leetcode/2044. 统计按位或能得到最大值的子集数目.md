
## 题目
[LeetCode题目解析：2044. 统计按位或能得到最大值的子集数目](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/description/?envType=daily-question&envId=2025-07-28)

难度：中等

给你一个整数数组 `nums` ，请你找出 `nums` 子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的不同非空子集的数目 。

如果数组 `a` 可以由数组 `b` 删除一些元素（或不删除）得到，则认为数组 `a` 是数组 `b` 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。

对数组 `a` 执行 **按位或** ，结果等于 `a[0] OR a[1] OR ... OR a[a.length - 1]`（下标从 0 开始）。

## 题解

### 思路
其实就是枚举，用回溯法进行枚举。

```python
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        maxOr, cnt = 0,0
        def dfs(pos:int, orVal:int) -> None:
            nonlocal maxOr, cnt
            if pos == len(nums):
                if orVal>maxOr: maxOr,cnt = orVal,1
                elif orVal==maxOr: cnt += 1
                return
            dfs(pos+1, orVal)
            dfs(pos+1, orVal | nums[pos])
            return
        dfs(0,0)
        return cnt
```
